{"ast":null,"code":"const API_BASE = \"https://localhost:5001/api/notes\";\nconst toApiColor = c => {\n  switch (c) {\n    case \"yellow\":\n      return \"Yellow\";\n    case \"pink\":\n      return \"Pink\";\n    case \"blue\":\n      return \"Blue\";\n    case \"green\":\n      return \"Green\";\n  }\n};\nconst fromApiColor = c => {\n  switch (c) {\n    case \"Yellow\":\n      return \"yellow\";\n    case \"Pink\":\n      return \"pink\";\n    case \"Blue\":\n      return \"blue\";\n    case \"Green\":\n      return \"green\";\n  }\n};\nconst toUiNote = n => ({\n  ...n,\n  color: fromApiColor(n.color)\n});\nasync function request(url, init) {\n  const res = await fetch(url, init);\n  if (!res.ok) {\n    const text = await res.text().catch(() => \"\");\n    throw new Error(`${res.status} ${text}`);\n  }\n\n  // 204 No Content\n  if (res.status === 204) {\n    return undefined;\n  }\n\n  // Sometimes APIs return 200 with empty body\n  const text = await res.text();\n  if (!text) {\n    return undefined;\n  }\n  return JSON.parse(text);\n}\nexport const NotesApi = {\n  async getNotes() {\n    const apiNotes = await request(API_BASE);\n    return apiNotes.map(toUiNote);\n  },\n  async createNote(dto) {\n    const payload = {\n      ...dto,\n      color: toApiColor(dto.color) // \"yellow\" -> \"Yellow\"\n    };\n    const created = await request(API_BASE, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(payload)\n    });\n    return toUiNote(created); // \"Yellow\" -> \"yellow\"\n  },\n  async updateNote(id, patch) {\n    const {\n      color,\n      ...rest\n    } = patch;\n    const payload = {\n      ...rest,\n      ...(color ? {\n        color: toApiColor(color)\n      } : {})\n    };\n\n    // Backend uses int? → make sure we send integers (no decimals / NaN)\n    const roundIfNumber = v => typeof v === \"number\" && Number.isFinite(v) ? Math.round(v) : undefined;\n    if (payload.x !== undefined) payload.x = roundIfNumber(payload.x);\n    if (payload.y !== undefined) payload.y = roundIfNumber(payload.y);\n    if (payload.w !== undefined) payload.w = roundIfNumber(payload.w);\n    if (payload.h !== undefined) payload.h = roundIfNumber(payload.h);\n    if (payload.z !== undefined) payload.z = roundIfNumber(payload.z);\n\n    // Remove any fields that became undefined (avoids weird JSON)\n    Object.keys(payload).forEach(k => {\n      if (payload[k] === undefined) delete payload[k];\n    });\n    const updated = await request(`${API_BASE}/${id}`, {\n      method: \"PATCH\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(payload)\n    });\n    return toUiNote(updated);\n  },\n  async deleteNote(id) {\n    await request(`${API_BASE}/${id}`, {\n      method: \"DELETE\"\n    });\n  }\n};","map":{"version":3,"names":["API_BASE","toApiColor","c","fromApiColor","toUiNote","n","color","request","url","init","res","fetch","ok","text","catch","Error","status","undefined","JSON","parse","NotesApi","getNotes","apiNotes","map","createNote","dto","payload","created","method","headers","body","stringify","updateNote","id","patch","rest","roundIfNumber","v","Number","isFinite","Math","round","x","y","w","h","z","Object","keys","forEach","k","updated","deleteNote"],"sources":["C:/Development/Tempo/sticky-notes/src/api/notesApi.ts"],"sourcesContent":["import { Note, NoteCreate, NotePatch, NoteColor } from \"../types\";\r\n\r\ntype ApiNoteColor = \"Yellow\" | \"Pink\" | \"Blue\" | \"Green\";\r\n\r\ntype ApiNote = Omit<Note, \"color\"> & { color: ApiNoteColor };\r\ntype ApiNoteCreate = Omit<NoteCreate, \"color\"> & { color: ApiNoteColor };\r\ntype ApiNotePatch = Partial<ApiNoteCreate>;\r\n\r\nconst API_BASE = \"https://localhost:5001/api/notes\";\r\n\r\nconst toApiColor = (c: NoteColor): ApiNoteColor => {\r\n  switch (c) {\r\n    case \"yellow\":\r\n      return \"Yellow\";\r\n    case \"pink\":\r\n      return \"Pink\";\r\n    case \"blue\":\r\n      return \"Blue\";\r\n    case \"green\":\r\n      return \"Green\";\r\n  }\r\n};\r\n\r\nconst fromApiColor = (c: ApiNoteColor): NoteColor => {\r\n  switch (c) {\r\n    case \"Yellow\":\r\n      return \"yellow\";\r\n    case \"Pink\":\r\n      return \"pink\";\r\n    case \"Blue\":\r\n      return \"blue\";\r\n    case \"Green\":\r\n      return \"green\";\r\n  }\r\n};\r\n\r\nconst toUiNote = (n: ApiNote): Note => ({ ...n, color: fromApiColor(n.color) });\r\n\r\nasync function request<T>(url: string, init?: RequestInit): Promise<T> {\r\n  const res = await fetch(url, init);\r\n\r\n  if (!res.ok) {\r\n    const text = await res.text().catch(() => \"\");\r\n    throw new Error(`${res.status} ${text}`);\r\n  }\r\n\r\n  // 204 No Content\r\n  if (res.status === 204) {\r\n    return undefined as unknown as T;\r\n  }\r\n\r\n  // Sometimes APIs return 200 with empty body\r\n  const text = await res.text();\r\n  if (!text) {\r\n    return undefined as unknown as T;\r\n  }\r\n\r\n  return JSON.parse(text) as T;\r\n}\r\n\r\nexport const NotesApi = {\r\n  async getNotes(): Promise<Note[]> {\r\n    const apiNotes = await request<ApiNote[]>(API_BASE);\r\n    return apiNotes.map(toUiNote);\r\n  },\r\n\r\nasync createNote(dto: NoteCreate): Promise<Note> {\r\n  const payload = {\r\n    ...dto,\r\n    color: toApiColor(dto.color) // \"yellow\" -> \"Yellow\"\r\n  };\r\n\r\n  const created = await request<ApiNote>(API_BASE, {\r\n    method: \"POST\",\r\n    headers: { \"Content-Type\": \"application/json\" },\r\n    body: JSON.stringify(payload)\r\n  });\r\n\r\n  return toUiNote(created); // \"Yellow\" -> \"yellow\"\r\n},\r\n\r\nasync updateNote(id: string, patch: NotePatch): Promise<Note> {\r\n  const { color, ...rest } = patch;\r\n\r\n  const payload: ApiNotePatch = {\r\n    ...rest,\r\n    ...(color ? { color: toApiColor(color) } : {})\r\n  };\r\n\r\n  // Backend uses int? → make sure we send integers (no decimals / NaN)\r\n  const roundIfNumber = (v: unknown) =>\r\n    typeof v === \"number\" && Number.isFinite(v) ? Math.round(v) : undefined;\r\n\r\n  if (payload.x !== undefined) payload.x = roundIfNumber(payload.x) as any;\r\n  if (payload.y !== undefined) payload.y = roundIfNumber(payload.y) as any;\r\n  if (payload.w !== undefined) payload.w = roundIfNumber(payload.w) as any;\r\n  if (payload.h !== undefined) payload.h = roundIfNumber(payload.h) as any;\r\n  if (payload.z !== undefined) payload.z = roundIfNumber(payload.z) as any;\r\n\r\n  // Remove any fields that became undefined (avoids weird JSON)\r\n  (Object.keys(payload) as (keyof ApiNotePatch)[]).forEach((k) => {\r\n    if (payload[k] === undefined) delete payload[k];\r\n  });\r\n\r\n  const updated = await request<ApiNote>(`${API_BASE}/${id}`, {\r\n    method: \"PATCH\",\r\n    headers: { \"Content-Type\": \"application/json\" },\r\n    body: JSON.stringify(payload)\r\n  });\r\n\r\n  return toUiNote(updated);\r\n}\r\n,\r\n\r\n  async deleteNote(id: string): Promise<void> {\r\n    await request<void>(`${API_BASE}/${id}`, { method: \"DELETE\" });\r\n  }\r\n};\r\n"],"mappings":"AAQA,MAAMA,QAAQ,GAAG,kCAAkC;AAEnD,MAAMC,UAAU,GAAIC,CAAY,IAAmB;EACjD,QAAQA,CAAC;IACP,KAAK,QAAQ;MACX,OAAO,QAAQ;IACjB,KAAK,MAAM;MACT,OAAO,MAAM;IACf,KAAK,MAAM;MACT,OAAO,MAAM;IACf,KAAK,OAAO;MACV,OAAO,OAAO;EAClB;AACF,CAAC;AAED,MAAMC,YAAY,GAAID,CAAe,IAAgB;EACnD,QAAQA,CAAC;IACP,KAAK,QAAQ;MACX,OAAO,QAAQ;IACjB,KAAK,MAAM;MACT,OAAO,MAAM;IACf,KAAK,MAAM;MACT,OAAO,MAAM;IACf,KAAK,OAAO;MACV,OAAO,OAAO;EAClB;AACF,CAAC;AAED,MAAME,QAAQ,GAAIC,CAAU,KAAY;EAAE,GAAGA,CAAC;EAAEC,KAAK,EAAEH,YAAY,CAACE,CAAC,CAACC,KAAK;AAAE,CAAC,CAAC;AAE/E,eAAeC,OAAOA,CAAIC,GAAW,EAAEC,IAAkB,EAAc;EACrE,MAAMC,GAAG,GAAG,MAAMC,KAAK,CAACH,GAAG,EAAEC,IAAI,CAAC;EAElC,IAAI,CAACC,GAAG,CAACE,EAAE,EAAE;IACX,MAAMC,IAAI,GAAG,MAAMH,GAAG,CAACG,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,MAAM,EAAE,CAAC;IAC7C,MAAM,IAAIC,KAAK,CAAC,GAAGL,GAAG,CAACM,MAAM,IAAIH,IAAI,EAAE,CAAC;EAC1C;;EAEA;EACA,IAAIH,GAAG,CAACM,MAAM,KAAK,GAAG,EAAE;IACtB,OAAOC,SAAS;EAClB;;EAEA;EACA,MAAMJ,IAAI,GAAG,MAAMH,GAAG,CAACG,IAAI,CAAC,CAAC;EAC7B,IAAI,CAACA,IAAI,EAAE;IACT,OAAOI,SAAS;EAClB;EAEA,OAAOC,IAAI,CAACC,KAAK,CAACN,IAAI,CAAC;AACzB;AAEA,OAAO,MAAMO,QAAQ,GAAG;EACtB,MAAMC,QAAQA,CAAA,EAAoB;IAChC,MAAMC,QAAQ,GAAG,MAAMf,OAAO,CAAYP,QAAQ,CAAC;IACnD,OAAOsB,QAAQ,CAACC,GAAG,CAACnB,QAAQ,CAAC;EAC/B,CAAC;EAEH,MAAMoB,UAAUA,CAACC,GAAe,EAAiB;IAC/C,MAAMC,OAAO,GAAG;MACd,GAAGD,GAAG;MACNnB,KAAK,EAAEL,UAAU,CAACwB,GAAG,CAACnB,KAAK,CAAC,CAAC;IAC/B,CAAC;IAED,MAAMqB,OAAO,GAAG,MAAMpB,OAAO,CAAUP,QAAQ,EAAE;MAC/C4B,MAAM,EAAE,MAAM;MACdC,OAAO,EAAE;QAAE,cAAc,EAAE;MAAmB,CAAC;MAC/CC,IAAI,EAAEZ,IAAI,CAACa,SAAS,CAACL,OAAO;IAC9B,CAAC,CAAC;IAEF,OAAOtB,QAAQ,CAACuB,OAAO,CAAC,CAAC,CAAC;EAC5B,CAAC;EAED,MAAMK,UAAUA,CAACC,EAAU,EAAEC,KAAgB,EAAiB;IAC5D,MAAM;MAAE5B,KAAK;MAAE,GAAG6B;IAAK,CAAC,GAAGD,KAAK;IAEhC,MAAMR,OAAqB,GAAG;MAC5B,GAAGS,IAAI;MACP,IAAI7B,KAAK,GAAG;QAAEA,KAAK,EAAEL,UAAU,CAACK,KAAK;MAAE,CAAC,GAAG,CAAC,CAAC;IAC/C,CAAC;;IAED;IACA,MAAM8B,aAAa,GAAIC,CAAU,IAC/B,OAAOA,CAAC,KAAK,QAAQ,IAAIC,MAAM,CAACC,QAAQ,CAACF,CAAC,CAAC,GAAGG,IAAI,CAACC,KAAK,CAACJ,CAAC,CAAC,GAAGpB,SAAS;IAEzE,IAAIS,OAAO,CAACgB,CAAC,KAAKzB,SAAS,EAAES,OAAO,CAACgB,CAAC,GAAGN,aAAa,CAACV,OAAO,CAACgB,CAAC,CAAQ;IACxE,IAAIhB,OAAO,CAACiB,CAAC,KAAK1B,SAAS,EAAES,OAAO,CAACiB,CAAC,GAAGP,aAAa,CAACV,OAAO,CAACiB,CAAC,CAAQ;IACxE,IAAIjB,OAAO,CAACkB,CAAC,KAAK3B,SAAS,EAAES,OAAO,CAACkB,CAAC,GAAGR,aAAa,CAACV,OAAO,CAACkB,CAAC,CAAQ;IACxE,IAAIlB,OAAO,CAACmB,CAAC,KAAK5B,SAAS,EAAES,OAAO,CAACmB,CAAC,GAAGT,aAAa,CAACV,OAAO,CAACmB,CAAC,CAAQ;IACxE,IAAInB,OAAO,CAACoB,CAAC,KAAK7B,SAAS,EAAES,OAAO,CAACoB,CAAC,GAAGV,aAAa,CAACV,OAAO,CAACoB,CAAC,CAAQ;;IAExE;IACCC,MAAM,CAACC,IAAI,CAACtB,OAAO,CAAC,CAA4BuB,OAAO,CAAEC,CAAC,IAAK;MAC9D,IAAIxB,OAAO,CAACwB,CAAC,CAAC,KAAKjC,SAAS,EAAE,OAAOS,OAAO,CAACwB,CAAC,CAAC;IACjD,CAAC,CAAC;IAEF,MAAMC,OAAO,GAAG,MAAM5C,OAAO,CAAU,GAAGP,QAAQ,IAAIiC,EAAE,EAAE,EAAE;MAC1DL,MAAM,EAAE,OAAO;MACfC,OAAO,EAAE;QAAE,cAAc,EAAE;MAAmB,CAAC;MAC/CC,IAAI,EAAEZ,IAAI,CAACa,SAAS,CAACL,OAAO;IAC9B,CAAC,CAAC;IAEF,OAAOtB,QAAQ,CAAC+C,OAAO,CAAC;EAC1B,CAAC;EAGC,MAAMC,UAAUA,CAACnB,EAAU,EAAiB;IAC1C,MAAM1B,OAAO,CAAO,GAAGP,QAAQ,IAAIiC,EAAE,EAAE,EAAE;MAAEL,MAAM,EAAE;IAAS,CAAC,CAAC;EAChE;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}